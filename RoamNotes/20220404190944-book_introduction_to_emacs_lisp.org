:PROPERTIES:
:ID:       2a3287c2-0103-4e20-9dc0-5f1ec602fd7c
:END:
#+title: [Book] Introduction to Emacs Lisp
#+date: [2022-04-04 seg 19:09]

Those notes are based on the free pdf called "An Introduction to Programming in
Emacs Lisp".

+ Lisp History

  Lisp was first developed in the late 1950s at the MIT for research in
  artificial intelligence. The great power of the Lisp language makes it
  superior for other purposes as well, such as writing editor commands and
  integrated environments.

  GNU Emacs Lisp is largely inspired by Maclisp, which was written at MIT in the
  1960s. It is somewhat inspired by Common Lisp, which became a standard in the
  1980s. However, Emacs Lisp is much simpler than Common Lisp. (The standard
  Emacs distribution contains an optional extensions file, cl.el, that adds many
  Common Lisp features to Emacs Lisp.)

* 1 - Lisp Processing

  Lisp stands for LISt Processing, and the programming language handles lists
  (and lists of lists) by putting them between parentheses. Those parentheses
  mark the boundaries of the list.

  #+begin_src elisp :tangle no
    ;; Lisp example
    '(rose volet daisy buttercup)
  #+end_src

  In Lisp, both data and programs are represented the same way: lists. Since a
  program looks like data, one program may easily serve as data for another;
  this is a very powerful feature of Lisp.

** Lisp Atoms

   Technically speaking, a list in Lisp consists of parentheses surrounding
   atoms separated by whitespace or surrounding other lists or surrounding both
   atoms and other lists.

   The printed representation of both atoms and lists are called /symbolic
   expressions/ or, more concisely, /s-expressions/.

** Programs

   A list in Lisp is a program ready to run. If you run it (for which the Lisp
   jargon is /evaluate/), the computer will do one of three: do nothing except
   return to you the list itself; send you an error message; or, treat the first
   symbol in the list as a command to do something.

   The single apostrophe, /'/, is called a /quote/; when it precedes a list, it
   tells Lisp to do nothing with the list, other than take it as it is written.

   But, if there is no quote preceding a list, the first item of the list is
   special: it is a command for the computer to obey. In Lisp, these commands
   are called /functions/.

   #+begin_src elisp :tangle no
     (+ 2 2) ; C-x C-e
   #+end_src

   In Lisp, one set of instructions can be attached to several names. On the
   other hand, a symbol can have only one function definition attached to it at
   a time.

** Lisp Interpreter

   First, it looks to see whether there is a quote before the list; if there is,
   the interpreter just gives us the list.  On the other hand, if there is no
   quote, the interpreter looks at the first element in the list and see whether
   it has a function definition. If it does, the interpreter carries out the
   instructions in the function definition. Otherwise, the interpreter prints an
   error message.

   There are some special functions that don't behave like normal functions and
   those are called /special forms/. They are used for special jobs, like
   defining a function, and there are not many of them.

   As well as special forms, there are also /macros/. A macro is a construct
   defined in Lisp, which differs from a function in that it translates a Lisp
   expression into another expression that is to be evaluated in place of the
   original expression.

   [...]

   When the Lisp interpreter works on an expression, the term for the activity
   is called /evaluation/. We say that the interpreter "evaluates the
   expression".

*** Byte Compiling

    One other aspect of interpreting: the Lisp interpreter is able to interpret
    two kinds of entity: humanly readable code, on which we will focus
    exclusively, and specially processes code, called /byte compiled/ code,
    which is not humanly readable. Byte compiled code runs faster than humanly
    readable code.

    You can transform humanly readable code into byte compiled code by running
    one of the compile commands such as /byte-compile-file/. Byte compiled code
    is usually stored in a file that ends with a /.elc/ extension rather than a
    /.el/ extension.

    As a practical matter, for most things you might do to customize or extend
    Emacs, you do not need to byte compile.

** Variables

   In Emacs Lisp, a symbol can have a value attached to it just as it can have a
   function definition attached to it. [...] A symbol that has a value is often
   called a variable.

** Arguments

   + Marker: a special object representing a buffer position.

     This is a specific feature of Emacs Lisp.

     In Emacs, locations in a buffer are recorded as markers. When the mark is
     set with the C-@ or C-SPC command, its position is kept as a marker. The
     mark can be considered a number - the number of characters the location is
     from the beginning of the buffer.

   + 'p' stands for "predicate".

     In the jargon used by the early Lisp researchers, a predicate refers to a
     function to determine whether some property is true or false.

     /number-or-marker-p/.

   + The /message/ function.

     This function is used to send messages to the user, similar to a
     console.log from javascript.

     #+begin_src elisp :tangle no
       (message "This message appears in the echo area!")

       (message "The name of this buffer: %s" (buffer-name))

       (message "The value of fill-column: %d" fill-column)
     #+end_src

** Binding a Value to a Variable

   Instead of thinking in terms of "assignment", the is another of thinking
   about binding values to variables and dealing with /set/ and /setq/, which is
   to say that /set/ and /setq/ make the symbol /point/ to the list.

   + set

     Note that when you use /set/, you need to quote both arguments to /set/,
     unless you want them evaluated.

     #+begin_src elisp :tangle no
       (set 'flowers '(rose violet daisy buttercup))

       flowers
       'flowers
     #+end_src

   + setq

     As a practical matter, you almost always quote the first argument to
     /set/. The combination of /set/ and a quoted first argument is so common
     that it has its own name: the special form /setq/.

     #+begin_src elisp :tangle no
       (setq carnivores '(lion tiger leopard))

       carnivores 'carnivores
     #+end_src

* 2 - Practicing Evaluation

  + The functions you evaluate by typing keystrokes are called /interactive/
    /functions/, or /commands/. How to make a function interactive is illustrated
    in the next chapter.

  In addition to typing keyboard commands, we have seen a second way to evaluate
  an expression: by positioning the cursor after a list and typing /C-x C-e/.

  #+begin_src elisp :tangle no
    (buffer-name) ; name of the file
    (buffer-file-name) ; full-path of the file
  #+end_src

  In those expressions, the parentheses tell the Lisp interpreter to treat
  buffer-name and buffer-file-name as functions; without the parentheses, the
  interpreter would attempt to evaluate the symbols as variables.

** Difference between file and buffer
  
   A file and a buffer are two different entities. A file is information
   recorded permanently in the computer (unless you delete it). A buffer, on the
   other hand, is information inside of Emacs that will vanish at the end of the
   editing session (or when you kill the buffer). Usually a buffer contains
   information that you have copied from a file; we say the buffer is visiting
   that file. This copy is what you work on and modify. Changes to the buffer do
   not change the file, until you save the buffer. When you save the buffer, the
   buffer is copied to the file and is thus saved permanently.

** Nil

   The symbol /nil/ is from the Latin word for "nothing". In Lisp, nil is also
   used to mean "false" and is a synonym for the empty list, ().
